!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Upscaler=t():e.Upscaler=t()}(self,(function(){return(()=>{var e,t,n,r,i={130:(e,t,n)=>{var r={"./Parameters_v0.json":[64,225]};function i(e){if(!n.o(r,e))return Promise.resolve().then((()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}));var t=r[e],i=t[0];return n.e(t[1]).then((()=>n.t(i,3)))}i.keys=()=>Object.keys(r),i.id=130,e.exports=i},487:(e,t,n)=>{var r={"./Parameters_v0.json":[885,876]};function i(e){if(!n.o(r,e))return Promise.resolve().then((()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}));var t=r[e],i=t[0];return n.e(t[1]).then((()=>n.t(i,3)))}i.keys=()=>Object.keys(r),i.id=487,e.exports=i},135:(e,t,n)=>{var r={"./Parameters_v0.json":[385,111]};function i(e){if(!n.o(r,e))return Promise.resolve().then((()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}));var t=r[e],i=t[0];return n.e(t[1]).then((()=>n.t(i,3)))}i.keys=()=>Object.keys(r),i.id=135,e.exports=i},148:(e,t,n)=>{var r={"./Parameters_v0.json":[15,535],"./Parameters_v2.0.json":[798,854],"./Parameters_v2.1.json":[848,767]};function i(e){if(!n.o(r,e))return Promise.resolve().then((()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}));var t=r[e],i=t[0];return n.e(t[1]).then((()=>n.t(i,3)))}i.keys=()=>Object.keys(r),i.id=148,e.exports=i},168:(e,t,n)=>{var r={"./Parameters_v0.json":[231,662]};function i(e){if(!n.o(r,e))return Promise.resolve().then((()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}));var t=r[e],i=t[0];return n.e(t[1]).then((()=>n.t(i,3)))}i.keys=()=>Object.keys(r),i.id=168,e.exports=i},67:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});const r={scale:1,upscaleFactor:1,pixel_value_rescale:1,kernelSize:3,inChannels:3,outChannels:[0,3]},i=class{constructor(e,t=r){this.gl=e,this.params=t;const n=this.gl;this.program=n.createAndLinkProgram(this.vertexShader(this.params.scale),this.fragmentShader(this.params.pixel_value_rescale));const i=this.program,o={},a={},s=this.uniforms(),u=this.attributes();s.forEach((e=>o[e]=n.getUniformLocation(i,e))),u.forEach((e=>{a[e]=n.createBuffer(),o[e]=n.getAttribLocation(i,e)})),this.locations=o,this.buffers=a,this.rgb=0}setTextureBufferForLayer(e){}enableAttributes(){const e=this.gl,t=this.locations;this.attributes().forEach((n=>{e.enableVertexAttribArray(t[n])}))}setFragmentPointers(){}useProgram(){this.gl.useProgram(this.program)}setVariables(){this.enableAttributes(),this.setVertexPointers(),this.setFragmentPointers()}setupProgram(){this.useProgram(),this.setVariables()}setVertexPointers(){const e=this.gl,t=this.locations,n=this.buffers,r=e.canvas.width,i=e.canvas.height;e.uniform2f(t.u_resolution,r,i),e.bindBuffer(e.ARRAY_BUFFER,n.a_position),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,r,0,0,i,0,i,r,0,r,i]),e.STATIC_DRAW),e.vertexAttribPointer(t.a_position,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,n.a_texCoord),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),e.STATIC_DRAW),e.vertexAttribPointer(t.a_texCoord,2,e.FLOAT,!1,0,0)}setOutput(e){e.drawToCanvas()}uniforms(){return["u_resolution","u_image"]}attributes(){return["a_position","a_texCoord"]}setInput(e){const t=this.gl;t.uniform1i(this.locations.u_image,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e.getTexture("INPUT")[0])}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n\n                // use medium precision for floats\n                precision mediump float;\n\n                // set input image uniform\n                uniform sampler2D u_image;\n\n                // Get texture position from vertex shader\n                in vec2 v_texCoord;\n\n                // Output pixel value\n                out vec4 outColor;\n                \n                void main() {\n                   // texture function pulls out the colors\n                   // from image with current position in\n                   // v_texCoord\n                   outColor= texture(u_image, v_texCoord);\n                 \n                }\n\n        ")}vertexShader(e=1){const t=this.gl;return t.createAndCompileShader(t.VERTEX_SHADER,`#version 300 es\n\n                // Position in canvas space\n                in vec2 a_position;\n                // Position in 0 to 1 space\n                in vec2 a_texCoord;\n\n                // Resolution of the input textures\n                uniform vec2 u_resolution;\n                // Return the texture co-ordinates\n                out vec2 v_texCoord;\n\n                void main() {\n                    //Convert the positions from (0, 0, w, h) to (-1, -1, 1, 1)\n                    //the higher the value of 'scale' the lower is the output resolution\n                    gl_Position = vec4((2.0/float(${e}))*a_position / u_resolution-1.0, 0, 1);\n\n                   //Texture pixel position\n                   v_texCoord = a_texCoord;\n                }\n        `)}run(){const e=this.gl;e.drawArrays(e.TRIANGLES,0,6)}}},9:(e,t,n)=>{"use strict";n.d(t,{Z:()=>a});var r=n(67);const i={scale:1,upscaleFactor:1,kernelSize:3,inChannels:4,outChannels:4};class o extends r.Z{constructor(e,t,n=i){super(e,n=n),this.weights=this.formatWeights(t)}formatWeights(e){return e}}const a=o},752:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(9);class i extends r.Z{constructor(e,t,n){super(e,t,n=n),this.in_channels=1,this.out_channels=8}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n\n              precision highp float;\n\n              layout(location = 0) out vec4 featureStack0;\n              layout(location = 1) out vec4 featureStack1;\n\n              uniform sampler2D u_image;\n              uniform sampler2D DilatedEdgeMask ;\n\n              uniform vec2 u_textureSize;\n\n              uniform vec4 u_kernel[18];\n              uniform vec4 u_bias[2];\n              uniform vec2 kernel_offset[9];\n\n              uniform float addResidual;\n              uniform float useDilated;\n              uniform float useRelu;\n\n\n              in vec2 v_texCoord;\n\n              vec4 relu(vec4 color){\n                return vec4(max(0.0, color.r),\n                            max(0.0, color.g),\n                            max(0.0, color.b),\n                            max(0.0, color.a));\n              }\n\n              void main() {\n\n                    vec2 onePixel = vec2(1.0, 1.0) / (u_textureSize);\n                    float dilated_edge = texture(DilatedEdgeMask, v_texCoord)[0]+useDilated;\n                    if(dilated_edge > 0.0){\n\n                        int kernelSize = kernel_offset.length();\n\n                        for (int i =0; i < 9; i++){\n\n                            featureStack0 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[2*i + 0];\n                            featureStack1 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[2*i + 1];\n\n                        }\n\n                        featureStack0 += u_bias[0];\n                        featureStack1 += u_bias[1];\n\n                        if(useRelu > 0.0){\n                            featureStack0 = relu(featureStack0);\n                            featureStack1 = relu(featureStack1);\n                        }\n\n                    }\n                    else{\n                        featureStack0 = vec4(0.0);\n                        featureStack1 = vec4(0.0);\n                    }\n              }\n        ")}attributes(){return["a_position","a_texCoord"]}uniforms(){return["u_resolution","u_textureSize","u_image","DilatedEdgeMask","useDilated","addResidual","useRelu","u_kernel","u_bias","kernel_offset","u_flipY"]}formatWeights(e){const t=e.weights,n=e.biases,r=[];let i=[],o=[];for(let e=0;e<3;e++)for(let t=0;t<3;t++)o.push(e%3),i.push(t);for(let e=0;e<9;e++){const n=i[e],a=o[e];for(let e=0;e<t.length;e++)r.push(t[e][0][a][n])}return{weights:r,biases:n}}setOutput(e){e.setBuffer(`Conv${this.params.layer_index}`);const t=this.gl;t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1])}setInput(e){const t=this.gl;t.uniform1i(this.locations.u_image,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e.getTexture("YUV")[0]),!0===this.params.useDilated&&(t.uniform1i(this.locations.DilatedEdgeMask,1),t.activeTexture(t.TEXTURE0+1),t.bindTexture(t.TEXTURE_2D,e.getTexture("DilatedEdgeMask")[0]))}setTextureBufferForLayer(e){e.createBufferWithTextures(`Conv${this.params.layer_index}`,2)}setFragmentPointers(){const e=this.gl,t=this.locations;let n=new Float32Array(this.weights.weights),r=new Float32Array(this.weights.biases);const i=new Float32Array([-1,-1,0,-1,1,-1,-1,0,0,0,1,0,-1,1,0,1,1,1]);e.uniform2f(t.u_textureSize,e.input.w,e.input.h),e.uniform4fv(t.u_kernel,n),e.uniform4fv(t.u_bias,r),e.uniform2fv(t.kernel_offset,i),e.uniform1f(t.u_flipY,1),!0===this.params.residual?e.uniform1f(t.addResidual,1):e.uniform1f(t.addResidual,0),!0===this.params.useDilated?e.uniform1f(t.useDilated,0):e.uniform1f(t.useDilated,1),!1===this.params.useReLU?e.uniform1f(t.useRelu,0):e.uniform1f(t.useRelu,1)}}const o=i},684:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(9);class i extends r.Z{constructor(e,t,n){super(e,t,n=n),this.in_channels=8,this.out_channels=8}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n              precision mediump float;\n\n\n              uniform sampler2D inputStack0 ;\n              uniform sampler2D inputStack1 ;\n\n\n              uniform sampler2D lastInput0 ;\n              uniform sampler2D lastInput1 ;\n\n\n              uniform sampler2D lastOutput0 ;\n              uniform sampler2D lastOutput1 ;\n\n              uniform sampler2D DilatedEdgeMask ;\n              uniform sampler2D yuv;\n\n              layout(location = 0) out vec4 outStack0;\n              layout(location = 1) out vec4 outStack1;\n              layout(location = 2) out vec4 outStack2;\n\n              uniform mat4 kernelMat[36];\n\n              uniform vec4 u_bias[2];\n\n              in vec2 v_texCoord;\n\n              //kernel_offset size 9 due to 3x3 kernels\n              uniform vec2 kernel_offset[9];\n              uniform vec2 u_textureSize;\n\n              uniform float addResidual;\n              uniform float addframediff;\n              uniform float useDilated;\n              uniform float useRelu;\n\n              vec4 relu(vec4 color){\n                return vec4(max(0.0, color.r),\n                            max(0.0, color.g),\n                            max(0.0, color.b),\n                            max(0.0, color.a));\n              }\n\n\n              void main() {\n                  // If the useDilated flag is false then the variable useDilated is 1\n                  // which leads to variable dilated_edge be always greater than 0\n                  float dilated_edge = texture(DilatedEdgeMask, v_texCoord)[0] +useDilated;\n\n                  // if 'addframediff' is set to 0 then error_diff is initialised 1.0 instead\n                  // of 0.0. As a result we don't loop through to calculate error_diff between\n                  // the previous and current frame neighborhood\n                  float error_diff = 1.0 - addframediff;\n\n                  vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n\n                    //Check the dilated mask\n                    if(dilated_edge > 0.0){\n                        // if addframediff is set to 0 then we don't execute this loop\n                        for (int i =0; i < 9*int(addframediff); i++){\n\n\n                            vec4 diff0  = texture(inputStack0, v_texCoord + onePixel *kernel_offset[i]) -  texture(lastInput0, v_texCoord + onePixel *kernel_offset[i]);\n                            vec4 diff1  = texture(inputStack1, v_texCoord + onePixel *kernel_offset[i]) -  texture(lastInput1, v_texCoord + onePixel *kernel_offset[i]);\n\n\n                            error_diff += dot(diff0, diff0);\n                            error_diff += dot(diff1, diff1);\n\n                        }\n                        if(error_diff > 0.0){\n\n\n                            for (int i =0; i < 9; i++){\n\n\n                                outStack0 += texture(inputStack0, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*4 + 0];\n                                outStack0 += texture(inputStack1, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*4 + 1];\n\n\n                                outStack1 += texture(inputStack0, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*4 + 2];\n                                outStack1 += texture(inputStack1, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*4 + 3];\n\n                            }\n\n\n                            outStack0 += u_bias[0];\n                            outStack1 += u_bias[1];\n\n                            if(useRelu > 0.0){\n                                outStack0 = relu(outStack0);\n                                outStack1 = relu(outStack1);\n                            }\n\n                            //Y channel will be added if the residual is set to\n                            // true in params\n                            float yChannel= texture(yuv, v_texCoord)[0]*addResidual;\n                            outStack0 +=  vec4(yChannel);\n                            outStack1 +=  vec4(yChannel);\n\n\n                        } else{\n                            outStack0 = texture(lastOutput0, v_texCoord);\n                            outStack1 = texture(lastOutput1, v_texCoord);\n\n                        }\n                    }\n                    else{\n                        float yChannel= texture(yuv, v_texCoord)[0]*addResidual;\n                        outStack0 =  vec4(yChannel);\n                        outStack1 =  vec4(yChannel);\n                    }\n\n                }\n        ")}attributes(){return["a_position","a_texCoord"]}uniforms(){return["u_resolution","u_textureSize","kernelMat","inputStack0","inputStack1","lastInput0","lastInput1","lastOutput0","lastOutput1","DilatedEdgeMask","yuv","addResidual","useDilated","useRelu","addframediff","u_bias","kernel_offset","u_flipY"]}formatWeights(e){const t=e.weights,n=[],r=[0,1,2,0,1,2,0,1,2],i=[0,0,0,1,1,1,2,2,2];for(let e=0;e<9;e++){const o=r[e],a=i[e];for(let e=0;e<4;e++)for(let r=0;r<4;r++)n.push(t[e][r][a][o]);for(let e=0;e<4;e++)for(let r=4;r<8;r++)n.push(t[e][r][a][o]);for(let e=4;e<8;e++)for(let r=0;r<4;r++)n.push(t[e][r][a][o]);for(let e=4;e<8;e++)for(let r=4;r<8;r++)n.push(t[e][r][a][o])}return{weights:n,biases:e.biases}}setOutput(e){this.layer_index,e.setBuffer(`Conv${this.params.layer_index}`);const t=this.gl;t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1])}setInput(e){const t=this.gl,n=this.params.layer_index;let r=0;const i=e.getTexture("Conv"+(n-1));for(let e=0;e<i.length;e++)t.activeTexture(t.TEXTURE0+e+r),t.uniform1i(this.locations[`inputStack${e}`],e+r),t.bindTexture(t.TEXTURE_2D,i[e]);r+=i.length;const o=e.getLastFrameTexture("Conv"+(n-1));for(let e=0;e<o.length;e++)t.activeTexture(t.TEXTURE0+e+r),t.uniform1i(this.locations[`lastInput${e}`],e+r),t.bindTexture(t.TEXTURE_2D,o[e]);r+=o.length;const a=e.getLastFrameTexture(`Conv${n}`);for(let e=0;e<a.length;e++)t.activeTexture(t.TEXTURE0+e+r),t.uniform1i(this.locations[`lastOutput${e}`],e+r),t.bindTexture(t.TEXTURE_2D,a[e]);if(r+=a.length,t.activeTexture(t.TEXTURE0+r),t.uniform1i(this.locations.yuv,r),t.bindTexture(t.TEXTURE_2D,e.getTexture("YUV")[0]),r+=1,!0===this.params.useDilated){const n=e.getTexture("DilatedEdgeMask");t.activeTexture(t.TEXTURE0+r),t.uniform1i(this.locations.DilatedEdgeMask,r),t.bindTexture(t.TEXTURE_2D,n[0]),r+=1}}setTextureBufferForLayer(e){const t=this.params.layer_index;e.createBufferWithTextures(`Conv${t}`,2)}setFragmentPointers(){const e=this.gl,t=this.locations,n=new Float32Array(this.weights.biases),r=new Float32Array([-1,-1,0,-1,1,-1,-1,0,0,0,1,0,-1,1,0,1,1,1]);e.uniform2f(t.u_textureSize,e.input.w,e.input.h),e.uniformMatrix4fv(t.kernelMat,!1,new Float32Array(this.weights.weights)),e.uniform1f(t.u_flipY,1),!0===this.params.residual?e.uniform1f(t.addResidual,1):e.uniform1f(t.addResidual,0),!0===this.params.frame_difference?e.uniform1f(t.addframediff,1):e.uniform1f(t.addframediff,0),!0===this.params.useDilated?e.uniform1f(t.useDilated,0):e.uniform1f(t.useDilated,1),!1===this.params.useReLU?e.uniform1f(t.useRelu,0):e.uniform1f(t.useRelu,1),e.uniform4fv(t.u_bias,n),e.uniform2fv(t.kernel_offset,r)}}const o=i},402:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(9);class i extends r.Z{constructor(e,t,n){super(e,t,n=n),this.in_channels=8,this.out_channels=9}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n\n            precision mediump float;\n\n\n            uniform sampler2D inputStack0 ;\n            uniform sampler2D inputStack1 ;\n\n\n            uniform sampler2D lastInput0;\n            uniform sampler2D lastInput1;\n\n\n            uniform sampler2D lastOutput0;\n            uniform sampler2D lastOutput1;\n            uniform sampler2D lastOutput2;\n\n            uniform sampler2D DilatedEdgeMask ;\n            uniform sampler2D yuv ;\n\n\n            layout(location = 0) out vec4 outStack0;\n            layout(location = 1) out vec4 outStack1;\n            layout(location = 2) out vec4 outStack2;\n\n            uniform mat4 kernelMat[54];\n\n            uniform vec4 u_bias[3];\n\n            in vec2 v_texCoord;\n\n            //kernel_offset size 9 due to 3x3 kernels\n            uniform vec2 kernel_offset[9];\n            uniform vec2 u_textureSize;\n\n\n            uniform float addResidual;\n            uniform float addframediff;\n            uniform float useDilated;\n            uniform float useRelu;\n\n            vec4 relu(vec4 color){\n                return vec4(max(0.0, color.r),\n                            max(0.0, color.g),\n                            max(0.0, color.b),\n                            max(0.0, color.a));\n              }\n\n            void main() {\n                vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n                float dilated_edge = texture(DilatedEdgeMask, v_texCoord)[0] + useDilated;\n\n                // if 'addframediff' is set to 0 then error_diff is initialised 1.0 instead\n                // of 0.0. As a result we don't loop through to calculate error_diff between\n                // the previous and current frame neighborhood\n                float error_diff = 1.0 - addframediff;\n\n                if(dilated_edge > 0.0){\n\n                    for (int i =0; i < 9*int(addframediff); i++){\n\n\n                        vec4 diff0  = texture(inputStack0, v_texCoord + onePixel *kernel_offset[i]) -  texture(lastInput0, v_texCoord + onePixel *kernel_offset[i]);\n                        vec4 diff1  = texture(inputStack1, v_texCoord + onePixel *kernel_offset[i]) -  texture(lastInput1, v_texCoord + onePixel *kernel_offset[i]);\n\n\n                        error_diff += dot(diff0, diff0);\n                        error_diff += dot(diff1, diff1);\n\n\n                    }\n\n                    if(error_diff > 0.0){\n\n\n                        for (int i =0; i < 9; i++){\n\n                            outStack0 += texture(inputStack0, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*6 + 0];\n                            outStack0 += texture(inputStack1, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*6 + 1];\n                            outStack1 += texture(inputStack0, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*6 + 2];\n                            outStack1 += texture(inputStack1, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*6 + 3];\n                            outStack2 += texture(inputStack0, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*6 + 4];\n                            outStack2 += texture(inputStack1, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*6 + 5];\n\n                        }\n                        outStack0 += u_bias[0];\n                        outStack1 += u_bias[1];\n                        outStack2 += u_bias[2];\n\n                        // if useRelu flag is set\n                        if(useRelu > 0.0){\n                            outStack0 = relu(outStack0);\n                            outStack1 = relu(outStack1);\n                            outStack2 = relu(outStack2);\n                        }\n\n                        // Y channel will be added if the residual is set to\n                        // true in params\n                        float yChannel = texture(yuv, v_texCoord)[0]*addResidual;\n                        outStack0 +=  vec4(yChannel);\n                        outStack1 +=  vec4(yChannel);\n                        outStack2 +=  vec4(yChannel);\n                    }\n                    else{\n                        outStack0 = texture(lastOutput0, v_texCoord);\n                        outStack1 = texture(lastOutput1, v_texCoord);\n                        outStack2 = texture(lastOutput2, v_texCoord);\n                    }\n                }\n                else{\n                    float yChannel = texture(yuv, v_texCoord)[0]*addResidual;\n                    outStack0 =  vec4(yChannel);\n                    outStack1 =  vec4(yChannel);\n                    outStack2 =  vec4(yChannel);\n                }\n\n            }\n        ")}attributes(){return["a_position","a_texCoord"]}uniforms(){return["u_resolution","u_textureSize","kernelMat","inputStack0","inputStack1","useDilated","lastInput0","lastInput1","addframediff","lastOutput0","lastOutput1","lastOutput2","DilatedEdgeMask","yuv","addResidual","useRelu","u_bias","kernel_offset","u_flipY"]}formatWeights(e){const t=e.weights,n=e.biases,r=[];let i=[],o=[];for(let e=0;e<3;e++)for(let t=0;t<3;t++)o.push(e%3),i.push(t);for(let e=0;e<9;e++){const n=i[e],a=o[e];for(let e=0;e<4;e++)for(let i=0;i<4;i++)r.push(t[e][i][a][n]);for(let e=0;e<4;e++)for(let i=4;i<8;i++)r.push(t[e][i][a][n]);for(let e=4;e<8;e++)for(let i=0;i<4;i++)r.push(t[e][i][a][n]);for(let e=4;e<8;e++)for(let i=4;i<8;i++)r.push(t[e][i][a][n]);for(let e=8;e<12;e++)for(let i=0;i<4;i++)8==e?r.push(t[e][i][a][n]):r.push(0);for(let e=8;e<12;e++)for(let i=4;i<8;i++)8==e?r.push(t[e][i][a][n]):r.push(0)}for(let e=9;e<12;e++)n.push(0);return{weights:r,biases:n}}setOutput(e){const t=this.params.layer_index;e.setBuffer(`Conv${t}`);const n=this.gl;n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1,n.COLOR_ATTACHMENT2])}setInput(e){const t=this.gl,n=this.params.layer_index;let r=0;const i=e.getTexture("Conv"+(n-1));for(let e=0;e<i.length;e++)t.activeTexture(t.TEXTURE0+e+r),t.uniform1i(this.locations[`inputStack${e}`],e+r),t.bindTexture(t.TEXTURE_2D,i[e]);r+=i.length;const o=e.getLastFrameTexture("Conv"+(n-1));for(let e=0;e<o.length;e++)t.activeTexture(t.TEXTURE0+e+r),t.uniform1i(this.locations[`lastInput${e}`],e+r),t.bindTexture(t.TEXTURE_2D,o[e]);r+=o.length;const a=e.getLastFrameTexture(`Conv${n}`);for(let e=0;e<a.length;e++)t.activeTexture(t.TEXTURE0+e+r),t.uniform1i(this.locations[`lastOutput${e}`],e+r),t.bindTexture(t.TEXTURE_2D,a[e]);if(r+=a.length,this.params.useDilated){const n=e.getTexture("DilatedEdgeMask");t.activeTexture(t.TEXTURE0+r),t.uniform1i(this.locations.DilatedEdgeMask,r),t.bindTexture(t.TEXTURE_2D,n[0]),r+=1}t.activeTexture(t.TEXTURE0+r),t.uniform1i(this.locations.yuv,r),t.bindTexture(t.TEXTURE_2D,e.getTexture("YUV")[0]),r+=1}setTextureBufferForLayer(e){const t=this.params.layer_index;e.createBufferWithTextures(`Conv${t}`,3)}setFragmentPointers(){const e=this.gl,t=this.locations,n=new Float32Array(this.weights.biases),r=new Float32Array([-1,-1,0,-1,1,-1,-1,0,0,0,1,0,-1,1,0,1,1,1]);e.uniform2f(t.u_textureSize,e.input.w,e.input.h),e.uniformMatrix4fv(t.kernelMat,!1,new Float32Array(this.weights.weights)),e.uniform1f(t.u_flipY,1),!0===this.params.residual?e.uniform1f(t.addResidual,1):e.uniform1f(t.addResidual,0),!0===this.params.frame_difference?e.uniform1f(t.addframediff,1):e.uniform1f(t.addframediff,0),!0===this.params.residual?e.uniform1f(t.useDilated,0):e.uniform1f(t.useDilated,1),!1===this.params.useReLU?e.uniform1f(t.useRelu,0):e.uniform1f(t.useRelu,1),e.uniform4fv(t.u_bias,n),e.uniform2fv(t.kernel_offset,r)}}const o=i},183:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(67);class i extends r.Z{constructor(e,t){super(e,t=t)}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n            precision mediump float;\n\n            uniform sampler2D inputStack0;\n            uniform sampler2D inputStack1;\n            uniform sampler2D inputStack2;\n\n            uniform sampler2D YUV;\n            uniform sampler2D EdgeMask;\n\n            uniform vec2 u_textureSize;\n            uniform float useEdgeMask;\n\n            in vec2 v_texCoord;\n            out vec4 outColor;\n\n            void main() {\n\n                if(texture(EdgeMask, v_texCoord)[0] == 0.0 && useEdgeMask == 1.0){\n                    outColor[0] = texture(YUV, v_texCoord)[0];\n                }\n                else{\n\n                    vec2 canvasCoords = v_texCoord*u_textureSize;\n\n                    int i = int(canvasCoords[0]);\n                    int j  = int(canvasCoords[1]);\n\n\n                    if(i % 3 == 0 && j % 3 ==0){\n                        outColor[0] = texture(inputStack0, v_texCoord)[0] ;\n                    }\n\n                    else if(i % 3 == 1 && j % 3 ==0){\n                        outColor[0] = texture(inputStack0, v_texCoord)[1];\n                    }\n\n                    else if(i % 3 == 2 && j % 3 == 0){\n                        outColor[0] = texture(inputStack0, v_texCoord)[2];\n                    }\n\n                    else if(i % 3 == 0 && j % 3 ==1){\n                        outColor[0] = texture(inputStack0, v_texCoord)[3];\n                    }\n                    else if(i % 3 == 1 && j % 3 ==1){\n                        outColor[0] = texture(inputStack1, v_texCoord)[0];\n                    }\n\n                    else if(i % 3 == 2 && j % 3 ==1){\n                        outColor[0] = texture(inputStack1, v_texCoord)[1];\n                    }\n\n                    else if(i % 3 == 0 && j % 3 ==2){\n                        outColor[0] = texture(inputStack1, v_texCoord)[2];\n                    }\n                    else if(i % 3 == 1 && j % 3 ==2){\n                        outColor[0] = texture(inputStack1, v_texCoord)[3];\n                    }\n                    else if(i % 3 == 2 && j % 3 ==2){\n                        outColor[0] = texture(inputStack2, v_texCoord)[0];\n                    }\n\n                }\n\n                    outColor[1] =  texture(YUV, v_texCoord)[1];\n                    outColor[2] =  texture(YUV, v_texCoord)[2];\n                    outColor[3] = 1.0;\n\n            }\n        ")}setOutput(e){e.setBuffer("PixelShuffle")}setTextureBufferForLayer(e){e.createBufferWithTextures("PixelShuffle",1,3)}setInput(e){const t=this.gl;t.uniform1i(this.locations.inputStack0,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e.getTexture(this.params.layerName)[0]),t.uniform1i(this.locations.inputStack1,1),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,e.getTexture(this.params.layerName)[1]),t.uniform1i(this.locations.inputStack2,2),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,e.getTexture(this.params.layerName)[2]),t.uniform1i(this.locations.YUV,3),t.activeTexture(t.TEXTURE3),t.bindTexture(t.TEXTURE_2D,e.getTexture("YUV")[0]),t.uniform1i(this.locations.EdgeMask,4),t.activeTexture(t.TEXTURE4),t.bindTexture(t.TEXTURE_2D,e.getTexture("EdgeMask")[0])}uniforms(){return["u_resolution","u_textureSize","YUV","inputStack0","inputStack1","inputStack2","useEdgeMask","bias","kernel_offset","u_flipY","EdgeMask"]}setFragmentPointers(){const e=this.gl,t=this.locations;e.drawBuffers([e.COLOR_ATTACHMENT0]),e.uniform1f(t.u_flipY,1),e.uniform1f(t.useEdgeMask,!0===this.params.useEdgeMask?1:0),e.uniform2f(t.u_textureSize,3*e.input.w,3*e.input.h),e.uniform1f(t.u_flipY,1)}}const o=i},201:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(67);class i extends r.Z{constructor(e,t){super(e,t=t)}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n\n\n              precision lowp float;\n\n              out vec4 DilatedEdgeMask;\n\n              uniform sampler2D mask;\n              uniform vec2 u_textureSize;\n\n              in vec2 v_texCoord;\n\n              vec2 onePixel;\n\n              uniform vec2 kernel_offset[49];\n\n              void main(){\n\n                onePixel = vec2(1.0, 1.0) / (u_textureSize);\n                float pix_val = texture(mask, v_texCoord)[0];\n\n                // Copy the non dilated pixel value to 2nd channel so that\n                // we can access both non dilated and dilated mask from a single\n                // texture\n                DilatedEdgeMask[1] = pix_val;\n\n                if(pix_val==0.0){\n                    for(int i=0; i<kernel_offset.length(); i++){\n\n                        // As we are using a square kernel,\n                        // as soon as we find a white pixel in the neighborhood\n                        // we push it to dilated mask\n\n                        pix_val = texture(mask, v_texCoord + (onePixel * kernel_offset[i]))[0];\n                        DilatedEdgeMask[0] = float((DilatedEdgeMask[0] == 1.0) || (pix_val == 1.0));\n                        // if(pix_val>0.0){break;}\n                    }\n                }\n                else{\n                    DilatedEdgeMask[0] = 1.0;\n                }\n\n            }\n        ")}setOutput(e){e.setBuffer("DilatedEdgeMask")}setInput(e){const t=this.gl;t.uniform1i(this.locations.mask,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e.getTexture("EdgeMask")[0])}setTextureBufferForLayer(e){e.createBufferWithTextures("DilatedEdgeMask",1)}uniforms(){return["u_resolution","u_textureSize","kernel_offset","mask","u_flipY"]}setFragmentPointers(){const e=this.gl,t=this.locations;let n=[];const r=Math.floor(3.5);for(let e=0;e<49;e++){let t=e%7-r,i=Math.floor(e/7)-r;n.push(t),n.push(i)}n=new Float32Array(n),e.uniform2f(t.u_textureSize,e.input.w,e.input.h),e.uniform2fv(t.kernel_offset,n)}}const o=i},911:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(67);class i extends r.Z{constructor(e,t){super(e,t=t)}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n\n\n              precision highp float;\n\n              layout(location = 0) out vec4 EdgeMask;\n\n              uniform sampler2D u_image;\n              uniform vec2 u_textureSize;\n\n              uniform float SobelKernel_x[9];\n              uniform float SobelKernel_y[9];\n              uniform float edge_thresh;\n\n              in vec2 v_texCoord;\n\n              vec2 onePixel;\n\n              // Get Y channel pixel\n              #define GET_PIXEL(_x, _y) (texture(u_image, v_texCoord + onePixel*vec2(_x, _y))[0])\n\n              void main(){\n\n                onePixel = vec2(1.0, 1.0) / (u_textureSize);\n\n                // Get horizontal and vertical Sobel response\n                vec2 dxy = vec2( GET_PIXEL(-1, -1)*SobelKernel_x[0] + GET_PIXEL(0, -1)*SobelKernel_x[1] + GET_PIXEL(1, -1)*SobelKernel_x[2]\n                                + GET_PIXEL(-1, 0)*SobelKernel_x[3] + GET_PIXEL(0, 0)*SobelKernel_x[4] + GET_PIXEL(1, 0)*SobelKernel_x[5]\n                                + GET_PIXEL(-1, 1)*SobelKernel_x[6]+ GET_PIXEL(0, 1)*SobelKernel_x[7] + GET_PIXEL(1, 1)*SobelKernel_x[8],\n\n                                GET_PIXEL(-1, -1)*SobelKernel_y[0] + GET_PIXEL(0, -1)*SobelKernel_y[1] + GET_PIXEL(1, -1)*SobelKernel_y[2]\n                                + GET_PIXEL(-1, 0)*SobelKernel_y[3] + GET_PIXEL(0, 0)*SobelKernel_y[4] + GET_PIXEL(1, 0)*SobelKernel_y[5]\n                                + GET_PIXEL(-1, 1)*SobelKernel_y[6]+ GET_PIXEL(0, 1)*SobelKernel_y[7] + GET_PIXEL(1, 1)*SobelKernel_y[8]);\n\n                float magnitude = length(dxy);\n\n                EdgeMask[0] = float(magnitude>edge_thresh);\n\n              }\n        ")}setOutput(e){e.setBuffer("EdgeMask")}setInput(e){const t=this.gl;t.uniform1i(this.locations.u_image,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e.getTexture("YUV")[0])}setTextureBufferForLayer(e){e.createBufferWithTextures("EdgeMask",1)}uniforms(){return["u_resolution","u_textureSize","edge_thresh","kernel_offset","u_image","u_flipY","SobelKernel_x","SobelKernel_y"]}setFragmentPointers(){const e=this.gl,t=this.locations;e.uniform2f(t.u_textureSize,e.input.w,e.input.h),e.uniform1f(t.edge_thresh,void 0===this.params.edge_thresh?.01:this.params.edge_thresh),e.uniform1fv(t.SobelKernel_x,new Float32Array([1,0,-1,2,0,-2,1,0,-1])),e.uniform1fv(t.SobelKernel_y,new Float32Array([1,2,1,0,0,0,-1,-2,-1]))}}const o=i},795:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(67);class i extends r.Z{constructor(e,t){super(e,t=t)}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n            \n              \n              precision highp float;\n            \n              out vec4 YCrCb;\n     \n              uniform sampler2D u_image;\n              \n              uniform mat3 rgb2yuv;\n \n           \n              in vec2 v_texCoord;\n            \n              void main() {\n                    // Convert the rgb to yuv with correcting for normalization\n                    YCrCb = vec4(texture(u_image, v_texCoord).rgb*rgb2yuv + vec3(0.0, 0.5, 0.5), 1.0); \n         \n                  \n              }\n        ")}setOutput(e){e.setBuffer("YUV")}setTextureBufferForLayer(e){e.createBufferWithTextures("YUV",1)}uniforms(){return["u_resolution","u_textureSize","u_kernel","u_bias","kernel_offset","u_image","u_flipY","rgb2yuv"]}setFragmentPointers(){const e=this.gl,t=this.locations;e.uniformMatrix3fv(t.rgb2yuv,!1,new Float32Array([.299,.587,.114,-.169,-.331,.5,.5,-.419,-.081]))}}const o=i},870:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(67);class i extends r.Z{constructor(e){super(e)}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n            \n              // Use medium precision for floats\n              precision mediump float;\n              \n              // Set input YCrCb uniform\n              uniform sampler2D YCrCb;\n\n              // Size of the output maybe? No used currently\n              uniform vec2 u_textureSize;\n\n              // Save the output image into this vec4\n              out vec4 RGB;\n\n              // YUV to RGB conversion matrix\n              uniform mat3 yuv2rgb;\n           \n              in vec2 v_texCoord;\n            \n              void main() {\n                    \n                    //Read the YCrCb texture and correct for normalization(needs review)\n                    vec3 a = texture(YCrCb, v_texCoord).rgb - vec3(0.0, 0.5, 0.5);\n\n                    //YUV to RGB  conversion\n                    RGB = vec4(a*yuv2rgb, 1.0);\n             \n              }\n        ")}setTextureBufferForLayer(e){e.createBufferWithTextures("RGB",1)}vertexShader(){const e=this.gl;return e.createAndCompileShader(e.VERTEX_SHADER,"#version 300 es\n                // Position in canvas space\n                in vec2 a_position;\n                // Position in 0 to 1 space\n                in vec2 a_texCoord;\n\n                // Resolution of the input textures\n                uniform vec2 u_resolution;\n\n                // Return the texture co-ordinates\n                out vec2 v_texCoord;\n\n                void main() {\n                    //Convert the positions from (0, 0, w, h) to (-1, -1, 1, 1)\n                   gl_Position = vec4((2.0*a_position / u_resolution-1.0)*vec2(1.0, -1.0), 0, 1);\n                   //Texture pixel position\n                   v_texCoord = a_texCoord;\n                }\n        ")}uniforms(){return["u_resolution","u_textureSize","u_flipY","YCrCb","yuv2rgb"]}setInput(e){const t=this.gl;t.uniform1i(this.locations.YCrCb,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e.getTexture("PixelShuffle")[0])}setFragmentPointers(){const e=this.gl,t=this.locations;e.uniformMatrix3fv(t.yuv2rgb,!1,new Float32Array([1,0,1.4,1,-.343,-.7111,1,1.765,0]))}}const o=i},891:(e,t,n)=>{"use strict";n.d(t,{Z:()=>a});var r=n(67);class i extends r.Z{constructor(e,t){super(e,t=t)}setOutput(){const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null)}setInput(e,t){const n=this.gl;n.useProgram(this.program),-1==t?n.uniform1i(this.locations.rgb,1):n.uniform1i(this.locations.rgb,0),n.uniform1f(this.locations.channelIndex,t),n.uniform1i(this.locations.u_image,0),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,e)}uniforms(){return["u_resolution","u_textureSize","channelIndex","u_flipY","rgb"]}setFragmentPointers(){this.gl.uniform1f(this.locations.u_flipY,-1)}vertexShader(e=1){const t=this.gl;return t.createAndCompileShader(t.VERTEX_SHADER,`#version 300 es\n\n                in vec2 a_position;\n                in vec2 a_texCoord;\n\n                uniform vec2 u_resolution;\n                out vec2 v_texCoord;\n\n                void main() {\n                   gl_Position = vec4(((2.0/float(${e}))*a_position / u_resolution-1.0)*vec2(1.0, -1.0), 0, 1);\n                   v_texCoord = a_texCoord;\n                }\n        `)}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n\n                precision highp float;\n                uniform sampler2D u_image;\n\n                in vec2 v_texCoord;\n                out vec4 outColor;\n                \n                uniform float channelIndex;\n                uniform int rgb;\n\n                void main() {\n                \n                   int c = int(channelIndex); \n                   if(rgb==0){\n                       // if rgb is 1 then convert a particular channel of the texture \n                       // to vec4\n                       outColor = vec4(vec3(texture(u_image, v_texCoord)[c]), 1.0);\n                   }\n                   else{\n                       // if rgb is not zero then show the rgb image\n                        outColor = texture(u_image, v_texCoord);\n                   }\n                }\n\n        ")}}const o=i,a=class{constructor(e,t,n){this.gl=e,this.frameBuffer=t,this.Parameters=n,this.layers=this.model(),this.layers.forEach((e=>{e.setupProgram(),e.setTextureBufferForLayer(t)}))}model(){return[]}async getImageBytesForLayer(e,t={maxChannels:4,startChannel:0,scale:1,rgb:!0,download:!1,frameIndex:0}){void 0!==t.maxChannels&&"number"==typeof t.maxChannels||(t.maxChannels=1),void 0!==t.startChannel&&"number"==typeof t.startChannel||(t.startChannel=0),void 0!==t.scale&&"number"==typeof t.scale||(t.scale=1),void 0!==t.frameIndex&&"number"==typeof t.frameIndex||(t.frameIndex=0),void 0!==t.rgb&&"boolean"==typeof t.rgb||(t.rgb=!0),void 0!==t.download&&"boolean"==typeof t.download||(t.download=!1);const n=this.gl;let r=new o(n,t);r.setupProgram();const i=this.frameBuffer,a=n.canvas;let s=0,u=0;async function l(o){if(n.enable(n.SCISSOR_TEST),n.scissor(0,0,a.width,a.height),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.disable(n.SCISSOR_TEST),s=Math.floor(o/4),u=o%4,0==t.rgb?r.setInput(i.textures[t.frameIndex][e][s],u):r.setInput(i.textures[t.frameIndex][e][s],-1),r.setOutput(),r.run(),1==t.download){let t=`Layer-${e}-channel-${o}`;await async function(e,t){let n=e.toDataURL("image/bmp"),r=new XMLHttpRequest;return r.onload=function(){let e=document.createElement("a");e.href=n,e.download=t,e.style.display="none",document.body.appendChild(e),e.click(),e.remove()},await r.open("GET",n,!1),console.log("Download started"),r.send(),void console.log("Download is complete")}(a,t)}}t.startChannel;for(var f=0;f<t.maxChannels;++f)await l(f)}getImageBytes(){for(const e in this.frameBuffer.textures)this.getImageBytesForLayer(e,{maxChannels:4,startChannel:0,scale:1,frameIndex:0,rgb:!1})}feedForward(){const e=this.frameBuffer;this.layers.forEach((t=>{t.setOutput(e),t.useProgram(),t.setInput(e),t.run()})),this.getImageBytes()}}},717:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>h});var r=n(891),i=n(795),o=n(911),a=n(201),s=n(870),u=n(752),l=n(684),f=n(402),d=n(183);class c extends r.Z{constructor(e,t,n){super(e,t,n)}async getImageBytes(){}model(){const e=this.gl,t=!0,n=!0;return e.resizeCanvasToDisplaySize(3),[new i.Z(e,{scale:3}),new o.Z(e,{scale:3,edge_thresh:.01}),new a.Z(e,{scale:3}),new u.Z(e,this.Parameters.conv1,{scale:3,layer_index:1,useDilated:t}),new l.Z(e,this.Parameters.conv2,{scale:3,layer_index:2,useDilated:t,frame_difference:n}),new l.Z(e,this.Parameters.conv3,{scale:3,layer_index:3,useDilated:t,frame_difference:n}),new l.Z(e,this.Parameters.conv4,{scale:3,layer_index:4,useDilated:t,frame_difference:n}),new l.Z(e,this.Parameters.conv5,{scale:3,layer_index:5,useDilated:t,frame_difference:n}),new l.Z(e,this.Parameters.conv6,{scale:3,layer_index:6,useDilated:t,frame_difference:n}),new l.Z(e,this.Parameters.conv7,{scale:3,layer_index:7,useDilated:t,residual:!0,frame_difference:n}),new l.Z(e,this.Parameters.conv8,{scale:3,layer_index:8,useDilated:t,frame_difference:n}),new l.Z(e,this.Parameters.conv9,{scale:3,layer_index:9,useDilated:t,frame_difference:n}),new f.Z(e,this.Parameters.conv10,{scale:3,layer_index:10,useDilated:t,residual:!1,useReLU:!0,frame_difference:n}),new d.Z(e,{layerName:"Conv10",useEdgeMask:t}),new s.Z(e)]}}const h=c},466:(e,t,n)=>{"use strict";n.d(t,{default:()=>o});const r=function(e,t){"string"==typeof e&&(e=document.getElementById(e));let n=e.getContext("webgl2");if(n.getExtension("EXT_color_buffer_float"))return window.gl=n,n||console.log("WebGL Not Supported"),n.canvas.w=n.canvas.width,n.canvas.h=n.canvas.height,n.clearCanvas=function(){n.clearColor(.5,.5,.5,1),n.viewport(0,0,n.drawingBufferWidth,n.drawingBufferHeight),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT|n.STENCIL_BUFFER_BIT)},n.input={h:t.h,w:t.w},n.viewport(0,0,e.width,e.height),n.createAndCompileShader=function(e,t){let r=n.createShader(e);if(n.shaderSource(r,t),n.compileShader(r),!n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(n.getShaderInfoLog(r));return r},n.createAndLinkProgram=function(e,t){let r=n.createProgram();if(n.attachShader(r,e),n.attachShader(r,t),n.linkProgram(r),!n.getProgramParameter(r,n.LINK_STATUS))throw new Error(n.getProgramInfoLog(r));return r},n.resizeCanvasToDisplaySize=function(t){let n=t||1;const r=e.clientWidth*n|0,i=e.clientHeight*n|0;return(e.width!==r||e.height!==i)&&(e.width=r,e.height=i,!0)},n;alert("need EXT_color_buffer_float")};Object.defineProperty(HTMLMediaElement.prototype,"playing",{get:function(){return!!(this.currentTime>0&&!this.paused&&!this.ended&&this.readyState>2)}});var i=n(877);const o=class{constructor(e,t){console.log("Initialized upscaler with",e),this.video=e,this.container=e.parentNode,this.height=Math.round(t.height/3)||240,this.width=Math.round(t.width/3)||426,this.scale=t.scale||3,this.networkName=t.network||"residual_5k",this.initEvents(),this.canvas=this.initCanvas(t),this.instantiateNetwork(e),this.enabled=!0,this.playing=!1,this.initializeNetwork(e)}async instantiateNetwork(e){const t=(async(e,t)=>"cnn_demo"===e?(await n(487)("./Parameters_v0.json")).default:"residual_3k"===e?(await n(148)("./Parameters_v0.json")).default:"residual_5k"===e?(await n(135)("./Parameters_v0.json")).default:"7k"===e?(await n(130)("./Parameters_v0.json")).default:"vdsr"===e?(await n(168)("./Parameters_v0.json")).default:void 0)(this.networkName);this.NetworkClass=await(async e=>"cnn_demo"===e?(await n.e(79).then(n.bind(n,592))).default:"residual_3k"===e?(await n.e(262).then(n.bind(n,249))).default:"residual_5k"===e?(await Promise.resolve().then(n.bind(n,717))).default:"7k"===e?(await n.e(962).then(n.bind(n,370))).default:"vdsr"===e?(await n.e(890).then(n.bind(n,529))).default:void 0)(this.networkName),this.networkParameters=await t,this.container.insertBefore(this.canvas,this.video.nextSibling)}disable(){const e=this.canvas,t=this.video,n=t.parentNode.getBoundingClientRect();t.width=n.width,t.height=n.height,t.style.width=n.width,t.style.height=n.height,e.style.visibility="hidden",t.style.visibility="visible",this.enabled=!1}enable(){const e=this.canvas,t=this.video;t.width=this.width,t.height=this.height,t.style.visibility="hidden",e.style.visibility="visible",this.enabled=!0,t.playing&&this.render()}initEvents(){const e={};["load","error","stop","start"].forEach((function(t){e[t]=new Event("vectorly-upscaler-"+t)})),this.events=e}async initializeNetwork(e){var t;if(await(t="canvas#"+this.canvas.id,new Promise(((e,n)=>{const r=document.querySelector(t);if(r)e(r);else{var i=new MutationObserver((n=>{n.forEach((n=>{const r=Array.from(n.addedNodes);for(const n of r)if(n.matches&&n.matches(t))return i.disconnect(),void e(n)}))}));i.observe(document.documentElement,{childList:!0,subtree:!0})}}))),await function(e){return new Promise(((t,n)=>{if(e.videoWidth*e.videoHeight>0)return console.log("Video wxh",e.videoWidth,e.videoHeight),void t({width:e.videoWidth,height:e.videoHeight});e.onloadedmetadata=function(){console.log("Video wxh",e.videoWidth,e.videoHeight),t({width:e.videoWidth,height:e.videoHeight})}}))}(e),this.canvas.width=this.width,this.canvas.height=this.height,this.gl=new r(this.canvas.id,{h:this.height,w:this.width}),this.gl){e.width=this.width,e.height=this.height,e.style.width=this.width,e.style.height=this.height,e.style.visibility="hidden",this.frameBuffer=new class{constructor(e){this.gl=e,this.iterations=0,this.textures=[{},{}],this.frame_buffers=[{},{}],this.inputTex=null}drawToCanvas(){const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null)}setBuffer(e){const t=this.gl,n=this.iterations%2;t.bindFramebuffer(t.FRAMEBUFFER,this.frame_buffers[n][e])}getInputTexture(){const e=this.gl;return null===this.inputTex&&(this.inputTex=e.createTexture()),this.inputTex}setInputImage(e){const t=this.getInputTexture();gl.bindTexture(gl.TEXTURE_2D,t),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA32F,gl.RGBA,gl.FLOAT,e),this.textures[0].INPUT=[t],this.textures[1].INPUT=[t]}createBufferWithTextures(e,t,n=1){const r=this.gl;for(let i=0;i<2;i++){const o=r.createFramebuffer();this.frame_buffers[i][e]=o,r.bindFramebuffer(r.FRAMEBUFFER,o);const a=[];for(let e=0;e<t;++e){const t=this.createAndSetupTexture();a.push(t),r.bindTexture(r.TEXTURE_2D,t),r.texImage2D(r.TEXTURE_2D,0,r.RGBA32F,r.input.w*n,r.input.h*n,0,r.RGBA,r.FLOAT,null),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+e,r.TEXTURE_2D,t,0)}this.textures[i][e]=a}}getTexture(e){const t=this.iterations%2;return this.textures[t][e]}getLastFrameTexture(e){const t=1-this.iterations%2;return this.textures[t][e]}createAndSetupTexture(){const e=this.gl,t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),t}}(this.gl),this.networkInstance=new this.NetworkClass(this.gl,this.frameBuffer,this.networkParameters),this.renderer=new class{constructor(e,t,n){this.gl=e,this.network=t,this.frameBuffer=n}loadVideo(e){const t=this.frameBuffer,n=this,r=document.getElementById("video");r.src=e,void 0!==r.requestVideoFrameCallback&&r.requestVideoFrameCallback((function(){t.setInputImage(r),t.iterations+=1,n.render()})),document.getElementById("play-interface").addEventListener("click",(function(){console.log("Playback"),document.getElementById("play-interface").style.display="none",r.play();const e=function(i){t.setInputImage(r),t.iterations+=1,n.render(),r.ended?console.log("Playback ended"):requestAnimationFrame(e)};requestAnimationFrame(e)}),!1)}loadImage(e){const t=new Image;t.src=e;const n=this.frameBuffer,r=this,i=this.network;t.onload=function(){n.setInputImage(t),r.render(),i.getImageBytes()}}render(){const e=this.gl,t=this.network;e.clearColor(.5,.5,.5,1),e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT|e.STENCIL_BUFFER_BIT),t.feedForward(),e.flush()}}(this.gl,this.networkInstance,this.frameBuffer);const t=this.frameBuffer,n=this.renderer;e.addEventListener("canplay",function(){this.frameBuffer.setInputImage(e),this.renderer.render()}.bind(this)),e.requestVideoFrameCallback&&e.requestVideoFrameCallback(function(){if(this.playing)return null;t.setInputImage(e),n.render()}.bind(this)),e.addEventListener("play",function(){this.render()}.bind(this)),document.dispatchEvent(this.events.load)}else document.dispatchEvent(this.events.error)}render(){if(this.playing)return null;const e=this.video;function t(){e.requestVideoFrameCallback?e.requestVideoFrameCallback(n):requestAnimationFrame(n)}const n=function(n){this.frameBuffer.setInputImage(e),this.renderer.render(),e.playing&&this.enabled?(t(),this.playing=!0):(document.dispatchEvent(this.events.stop),this.playing=!1)}.bind(this);t(),document.dispatchEvent(this.events.start)}initCanvas(e){let t=document.createElement("canvas");return t.id="canv-"+(e.id||(0,i.v4)()),t.width=e.width||this.width,t.height=e.height||this.height,t.style.left="50%",t.style.top="50%",t.style.transform="translate(-50%, -50%)",t.style.position="absolute",t}}},877:(e,t,n)=>{var r=n(570),i=n(171),o=i;o.v1=r,o.v4=i,e.exports=o},327:e=>{for(var t=[],n=0;n<256;++n)t[n]=(n+256).toString(16).substr(1);e.exports=function(e,n){var r=n||0,i=t;return[i[e[r++]],i[e[r++]],i[e[r++]],i[e[r++]],"-",i[e[r++]],i[e[r++]],"-",i[e[r++]],i[e[r++]],"-",i[e[r++]],i[e[r++]],"-",i[e[r++]],i[e[r++]],i[e[r++]],i[e[r++]],i[e[r++]],i[e[r++]]].join("")}},217:e=>{var t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);if(t){var n=new Uint8Array(16);e.exports=function(){return t(n),n}}else{var r=new Array(16);e.exports=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),r[t]=e>>>((3&t)<<3)&255;return r}}},570:(e,t,n)=>{var r,i,o=n(217),a=n(327),s=0,u=0;e.exports=function(e,t,n){var l=t&&n||0,f=t||[],d=(e=e||{}).node||r,c=void 0!==e.clockseq?e.clockseq:i;if(null==d||null==c){var h=o();null==d&&(d=r=[1|h[0],h[1],h[2],h[3],h[4],h[5]]),null==c&&(c=i=16383&(h[6]<<8|h[7]))}var m=void 0!==e.msecs?e.msecs:(new Date).getTime(),_=void 0!==e.nsecs?e.nsecs:u+1,v=m-s+(_-u)/1e4;if(v<0&&void 0===e.clockseq&&(c=c+1&16383),(v<0||m>s)&&void 0===e.nsecs&&(_=0),_>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");s=m,u=_,i=c;var p=(1e4*(268435455&(m+=122192928e5))+_)%4294967296;f[l++]=p>>>24&255,f[l++]=p>>>16&255,f[l++]=p>>>8&255,f[l++]=255&p;var x=m/4294967296*1e4&268435455;f[l++]=x>>>8&255,f[l++]=255&x,f[l++]=x>>>24&15|16,f[l++]=x>>>16&255,f[l++]=c>>>8|128,f[l++]=255&c;for(var g=0;g<6;++g)f[l+g]=d[g];return t||a(f)}},171:(e,t,n)=>{var r=n(217),i=n(327);e.exports=function(e,t,n){var o=t&&n||0;"string"==typeof e&&(t="binary"===e?new Array(16):null,e=null);var a=(e=e||{}).random||(e.rng||r)();if(a[6]=15&a[6]|64,a[8]=63&a[8]|128,t)for(var s=0;s<16;++s)t[o+s]=a[s];return t||i(a)}}},o={};function a(e){if(o[e])return o[e].exports;var t=o[e]={exports:{}};return i[e](t,t.exports,a),t.exports}return a.m=i,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,a.t=function(n,r){if(1&r&&(n=this(n)),8&r)return n;if("object"==typeof n&&n){if(4&r&&n.__esModule)return n;if(16&r&&"function"==typeof n.then)return n}var i=Object.create(null);a.r(i);var o={};e=e||[null,t({}),t([]),t(t)];for(var s=2&r&&n;"object"==typeof s&&!~e.indexOf(s);s=t(s))Object.getOwnPropertyNames(s).forEach((e=>o[e]=()=>n[e]));return o.default=()=>n,a.d(i,o),i},a.d=(e,t)=>{for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},a.f={},a.e=e=>Promise.all(Object.keys(a.f).reduce(((t,n)=>(a.f[n](e,t),t)),[])),a.u=e=>"upscaler."+{79:"cnn-demo",111:"residual-5k-params0",225:"7k-params0",262:"residual-3k",535:"residual-3k-params0",662:"vdsr-params0",767:"residual-3k-params2",854:"residual-3k-params1",876:"cnn-demo-params0",890:"vdsr",962:"model-7k"}[e]+".js",a.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n={},r="Upscaler:",a.l=(e,t,i,o)=>{if(n[e])n[e].push(t);else{var s,u;if(void 0!==i)for(var l=document.getElementsByTagName("script"),f=0;f<l.length;f++){var d=l[f];if(d.getAttribute("src")==e||d.getAttribute("data-webpack")==r+i){s=d;break}}s||(u=!0,(s=document.createElement("script")).charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.setAttribute("data-webpack",r+i),s.src=e),n[e]=[t];var c=(t,r)=>{s.onerror=s.onload=null,clearTimeout(h);var i=n[e];if(delete n[e],s.parentNode&&s.parentNode.removeChild(s),i&&i.forEach((e=>e(r))),t)return t(r)},h=setTimeout(c.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=c.bind(null,s.onerror),s.onload=c.bind(null,s.onload),u&&document.head.appendChild(s)}},a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;a.g.importScripts&&(e=a.g.location+"");var t=a.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");n.length&&(e=n[n.length-1].src)}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),a.p=e})(),(()=>{var e={179:0};a.f.j=(t,n)=>{var r=a.o(e,t)?e[t]:void 0;if(0!==r)if(r)n.push(r[2]);else{var i=new Promise(((n,i)=>{r=e[t]=[n,i]}));n.push(r[2]=i);var o=a.p+a.u(t),s=new Error;a.l(o,(n=>{if(a.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var i=n&&("load"===n.type?"missing":n.type),o=n&&n.target&&n.target.src;s.message="Loading chunk "+t+" failed.\n("+i+": "+o+")",s.name="ChunkLoadError",s.type=i,s.request=o,r[1](s)}}),"chunk-"+t,t)}};var t=(t,n)=>{for(var r,i,[o,s,u]=n,l=0,f=[];l<o.length;l++)i=o[l],a.o(e,i)&&e[i]&&f.push(e[i][0]),e[i]=0;for(r in s)a.o(s,r)&&(a.m[r]=s[r]);for(u&&u(a),t&&t(n);f.length;)f.shift()()},n=self.webpackChunkUpscaler=self.webpackChunkUpscaler||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})(),a(466)})().default}));