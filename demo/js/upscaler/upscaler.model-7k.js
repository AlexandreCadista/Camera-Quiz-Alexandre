(self.webpackChunkUpscaler=self.webpackChunkUpscaler||[]).push([[962],{370:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>g});var o=n(891),r=n(795),i=n(870),a=n(9);class u extends a.Z{constructor(e,t,n){super(e,t,n=n)}fragmentShader(){const e=this.gl,t=this.params.outChannels[1]-this.params.outChannels[0],n=Math.round((t+t%4)/4),o=this.params.kernelSize*this.params.kernelSize,r=n*o;return e.createAndCompileShader(e.FRAGMENT_SHADER,`#version 300 es\n            \n              \n              precision highp float;\n            \n              layout(location = 0) out vec4 featureStack0;\n              layout(location = 1) out vec4 featureStack1;\n              layout(location = 2) out vec4 featureStack2;\n              layout(location = 3) out vec4 featureStack3;\n              layout(location = 4) out vec4 featureStack4;\n              layout(location = 5) out vec4 featureStack5;\n              layout(location = 6) out vec4 featureStack6;\n              layout(location = 7) out vec4 featureStack7;\n              \n              uniform sampler2D u_image;\n              uniform vec2 u_textureSize;\n            \n            \n              uniform vec4 u_kernel[${r}];\n              uniform vec4 u_bias[${n}];\n              uniform vec2 kernel_offset[${o}];\n            \n              in vec2 v_texCoord;\n\n              vec4 relu(vec4 color){\n                return vec4(max(0.0, color.r),\n                            max(0.0, color.g),\n                            max(0.0, color.b),\n                            max(0.0, color.a));\n              }\n            \n              void main() {\n              \n                    vec2 onePixel = vec2(1.0, 1.0) / (u_textureSize);\n\n                    int kernelSize = kernel_offset.length();\n\n                    for (int i =0; i < kernelSize; i++){\n                        \n                        featureStack0 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 0];\n                        featureStack1 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 1];\n                        featureStack2 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 2];\n                        featureStack3 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 3];\n                        featureStack4 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 4];\n                        featureStack5 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 5];\n                        featureStack6 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 6];\n                        featureStack7 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 7];\n                    }\n                    \n                    \n                    \n                    featureStack0 += u_bias[0];\n                    featureStack1 += u_bias[1];\n                    featureStack2 += u_bias[2];\n                    featureStack3 += u_bias[3];\n                    featureStack4 += u_bias[4];\n                    featureStack5 += u_bias[5];\n                    featureStack6 += u_bias[6];\n                    featureStack7 += u_bias[7];\n                    \n\n                    featureStack0 = relu(featureStack0);\n                    featureStack1 = relu(featureStack1);\n                    featureStack2 = relu(featureStack2);\n                    featureStack3 = relu(featureStack3);\n                    featureStack4 = relu(featureStack4);\n                    featureStack5 = relu(featureStack5);\n                    featureStack6 = relu(featureStack6);\n                    featureStack7 = relu(featureStack7);\n                    \n\n              }\n        `)}attributes(){return["a_position","a_texCoord"]}uniforms(){return["u_resolution","u_textureSize","u_image","u_kernel","u_bias","kernel_offset","u_flipY"]}formatWeights(e){const t=e.weights.slice(this.params.outChannels[0],this.params.outChannels[1]),n=e.biases.slice(this.params.outChannels[0],this.params.outChannels[1]),o=[];let r=[],i=[];for(let e=0;e<this.params.kernelSize;e++)for(let t=0;t<this.params.kernelSize;t++)i.push(e%this.params.kernelSize),r.push(t);for(let e=0;e<this.params.kernelSize*this.params.kernelSize;e++){const n=r[e],a=i[e];for(let e=0;e<t.length;e+=4)for(let r=0;r<4;r++)o.push(t[r+e][0][a][n])}return{weights:o,biases:n}}setOutput(e){e.setBuffer("Conv1-1");const t=this.gl;t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1,t.COLOR_ATTACHMENT2,t.COLOR_ATTACHMENT3,t.COLOR_ATTACHMENT4,t.COLOR_ATTACHMENT5,t.COLOR_ATTACHMENT6,t.COLOR_ATTACHMENT7])}setInput(e){const t=this.gl;t.uniform1i(this.locations.u_image,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e.getTexture("YUV")[0])}setTextureBufferForLayer(e){const t=this.params.outChannels[1]-this.params.outChannels[0],n=Math.round((t+t%4)/4);e.createBufferWithTextures("Conv1-1",n)}setFragmentPointers(){const e=this.gl,t=this.locations;let n=new Float32Array(this.weights.weights),o=new Float32Array(this.weights.biases),r=[],i=Math.floor(this.params.kernelSize/2);for(let e=0;e<this.params.kernelSize*this.params.kernelSize;e++){let t=e%this.params.kernelSize-i,n=Math.floor(e/this.params.kernelSize)-i;r.push(t),r.push(n)}r=new Float32Array(r),e.uniform2f(t.u_textureSize,e.input.w,e.input.h),e.uniform4fv(t.u_kernel,n),e.uniform4fv(t.u_bias,o),e.uniform2fv(t.kernel_offset,r),e.uniform1f(t.u_flipY,1)}}const s=u;class l extends a.Z{constructor(e,t,n){super(e,t,n)}fragmentShader(){const e=this.params.outChannels[1]-this.params.outChannels[0],t=Math.round((e+e%4)/4),n=this.params.kernelSize*this.params.kernelSize,o=t*n,r=this.gl;return r.createAndCompileShader(r.FRAGMENT_SHADER,`#version 300 es\n            \n              \n              precision highp float;\n            \n              layout(location = 0) out vec4 featureStack0;\n              layout(location = 1) out vec4 featureStack1;\n              layout(location = 2) out vec4 featureStack2;\n              layout(location = 3) out vec4 featureStack3;\n              layout(location = 4) out vec4 featureStack4;\n              layout(location = 5) out vec4 featureStack5;\n              layout(location = 6) out vec4 featureStack6;\n              \n              uniform sampler2D u_image;\n              uniform vec2 u_textureSize;\n            \n            \n              uniform vec4 u_kernel[${o}];\n              uniform vec4 u_bias[${t}];\n              uniform vec2 kernel_offset[${n}];\n            \n              in vec2 v_texCoord;\n\n              vec4 relu(vec4 color){\n                return vec4(max(0.0, color.r),\n                            max(0.0, color.g),\n                            max(0.0, color.b),\n                            max(0.0, color.a));\n              }\n            \n              void main() {\n              \n                    vec2 onePixel = vec2(1.0, 1.0) / (u_textureSize);\n\n                    for (int i =0; i < kernel_offset.length(); i++){\n                    \n                        featureStack0 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 0];\n                        featureStack1 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 1];\n                        featureStack2 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 2];\n                        featureStack3 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 3];\n                        featureStack4 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 4];\n                        featureStack5 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 5];\n                        featureStack6 += texture(u_image, v_texCoord + (onePixel * kernel_offset[i]) )[0] * u_kernel[u_bias.length()*i + 6];\n                    }\n                    \n                    featureStack0 += u_bias[0];\n                    featureStack1 += u_bias[1];\n                    featureStack2 += u_bias[2];\n                    featureStack3 += u_bias[3];\n                    featureStack4 += u_bias[4];\n                    featureStack5 += u_bias[5];\n                    featureStack6 += u_bias[6];\n                    \n                \n                    featureStack0 = relu(featureStack0);\n                    featureStack1 = relu(featureStack1);\n                    featureStack2 = relu(featureStack2);\n                    featureStack3 = relu(featureStack3);\n                    featureStack4 = relu(featureStack4);\n                    featureStack5 = relu(featureStack5);\n                    featureStack6 = relu(featureStack6);\n                    \n\n              }\n        `)}attributes(){return["a_position","a_texCoord"]}uniforms(){return["u_resolution","u_textureSize","u_image","u_kernel","u_bias","kernel_offset","u_flipY"]}formatWeights(e){const t=e.weights.slice(this.params.outChannels[0],this.params.outChannels[1]),n=e.biases.slice(this.params.outChannels[0],this.params.outChannels[1]),o=[];let r=[],i=[];for(let e=0;e<this.params.kernelSize;e++)for(let t=0;t<this.params.kernelSize;t++)i.push(e%this.params.kernelSize),r.push(t);if(t.length%4!=0){let e=new Array;for(let t=0;t<this.params.kernelSize;t++){e.push(new Array);for(let n=0;n<this.params.kernelSize;n++)e[t].push(0)}for(let o=0;o<t.length%4;o++)t.push([e]),n.push(0)}for(let e=0;e<this.params.kernelSize*this.params.kernelSize;e++){const n=r[e],a=i[e];for(let e=0;e<t.length;e+=4)for(let r=0;r<4;r++)o.push(t[r+e][0][a][n])}return{weights:o,biases:n}}setOutput(e){e.setBuffer("Conv1-2");const t=this.gl;t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1,t.COLOR_ATTACHMENT2,t.COLOR_ATTACHMENT3,t.COLOR_ATTACHMENT4,t.COLOR_ATTACHMENT5,t.COLOR_ATTACHMENT6])}setInput(e){const t=this.gl;t.uniform1i(this.locations.u_image,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e.getTexture("YUV")[0])}setTextureBufferForLayer(e){const t=this.params.outChannels[1]-this.params.outChannels[0],n=Math.round((t+t%4)/4);e.createBufferWithTextures("Conv1-2",n)}setFragmentPointers(){const e=this.gl,t=this.locations;let n=new Float32Array(this.weights.weights),o=new Float32Array(this.weights.biases),r=[],i=Math.floor(this.params.kernelSize/2);for(let e=0;e<this.params.kernelSize*this.params.kernelSize;e++){let t=e%this.params.kernelSize-i,n=Math.floor(e/this.params.kernelSize)-i;r.push(t),r.push(n)}r=new Float32Array(r),e.uniform2f(t.u_textureSize,e.input.w,e.input.h),e.uniform4fv(t.u_kernel,n),e.uniform4fv(t.u_bias,o),e.uniform2fv(t.kernel_offset,r),e.uniform1f(t.u_flipY,1)}}const k=l;class c extends a.Z{constructor(e,t,n){super(e,t,n)}fragmentShader(){const e=this.params.outChannels[1]-this.params.outChannels[0],t=this.params.kernelSize*this.params.kernelSize,n=Math.round(this.params.inChannels/4+this.params.inChannels%4)*t,o=this.gl;return o.createAndCompileShader(o.FRAGMENT_SHADER,`#version 300 es\n            \n              \n              precision mediump float;\n              \n              /**\n               * Dividing the layer 2 in two parts\n               * part 1 convolves first 32 features from layer 1\n               * part 2 convolves rest 57 - 32 -> 25 features\n               * */\n\n              uniform sampler2D inputStack0 ;\n              uniform sampler2D inputStack1 ;\n              uniform sampler2D inputStack2 ;\n              uniform sampler2D inputStack3 ;\n              uniform sampler2D inputStack4 ;\n              uniform sampler2D inputStack5 ;\n              uniform sampler2D inputStack6 ;\n              uniform sampler2D inputStack7 ;\n              uniform sampler2D inputStack8 ;\n              uniform sampler2D inputStack9 ;\n              uniform sampler2D inputStack10;\n              uniform sampler2D inputStack11;\n              uniform sampler2D inputStack12;\n              uniform sampler2D inputStack13;\n              uniform sampler2D inputStack14;\n              \n              \n              //Use 5 out of 8 total texture channels for the output\n              layout(location = 0) out vec4 outStack0;\n              layout(location = 1) out vec4 outStack1;\n\n              /**\n               * For layer2 part 1\n               * per kernel size -> 0 to 9\n               * number of input textures -> 57\n               * Required array size -> 60*9 -> 540\n               * vec4 kernelN of size 135 provides -> 4*135 -> 540 positions\n               * Also we have 5 output features so we need 5 kernelNs\n               * */\n\n          \n              uniform vec4 kernel4[${n}];\n              \n              uniform mat4 kernelMat[${n}];\n              \n              \n              // 5 biases for 5 outputs\n              uniform float u_bias[${e}];\n              \n              in vec2 v_texCoord;\n              \n              //kernel_offset size 9 due to 3x3 kernels\n              uniform vec2 kernel_offset[${t}];\n              uniform vec2 u_textureSize;\n              \n             \n            \n              void main() {\n           \n                    vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n                    \n                    for (int i =0; i < kernel_offset.length(); i++){\n                    \n                    \n                        outStack0 += texture(inputStack0, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 0];\n                        outStack0 += texture(inputStack1, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 1];\n                        outStack0 += texture(inputStack2, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 2];\n                        outStack0 += texture(inputStack3, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 3];\n                        outStack0 += texture(inputStack4, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 4];\n                        outStack0 += texture(inputStack5, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 5];\n                        outStack0 += texture(inputStack6, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 6];\n                        outStack0 += texture(inputStack7, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 7];\n                        outStack0 += texture(inputStack8, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 8];\n                        outStack0 += texture(inputStack9, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 9];\n                        outStack0 += texture(inputStack10, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 10];\n                        outStack0 += texture(inputStack11, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 11];\n                        outStack0 += texture(inputStack12, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 12];\n                        outStack0 += texture(inputStack13, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 13];\n                        outStack0 += texture(inputStack14, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 14];\n\n\n\n                        outStack1[0] += dot(texture(inputStack0, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 0]);\n                        outStack1[0] += dot(texture(inputStack1, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 1]);\n                        outStack1[0] += dot(texture(inputStack2, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 2]);\n                        outStack1[0] += dot(texture(inputStack3, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 3]);\n                        outStack1[0] += dot(texture(inputStack4, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 4]);\n                        outStack1[0] += dot(texture(inputStack5, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 5]);\n                        outStack1[0] += dot(texture(inputStack6, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 6]);\n                        outStack1[0] += dot(texture(inputStack7, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 7]);\n                        outStack1[0] += dot(texture(inputStack8, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 8]);\n                        outStack1[0] += dot(texture(inputStack9, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 9]);\n                        outStack1[0] += dot(texture(inputStack10, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 10]);\n                        outStack1[0] += dot(texture(inputStack11, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 11]);\n                        outStack1[0] += dot(texture(inputStack12, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 12]);\n                        outStack1[0] += dot(texture(inputStack13, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 13]);\n                        outStack1[0] += dot(texture(inputStack14, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 14]);\n                             \n                    }\n                       \n                    outStack0[0] += u_bias[0];\n                    outStack0[0] = max(0.0, outStack0[0]);\n\n                    outStack0[1] += u_bias[1];\n                    outStack0[1] = max(0.0, outStack0[1]);\n\n                    outStack0[2] += u_bias[2];\n                    outStack0[2] = max(0.0, outStack0[2]);\n\n                    outStack0[3] += u_bias[3];\n                    outStack0[3] = max(0.0, outStack0[3]);\n                    \n                    \n                    outStack1[0] += u_bias[4];\n                    outStack1[0] = max(0.0, outStack1[0]);\n\n              }\n        `)}attributes(){return["a_position","a_texCoord"]}uniforms(){return["u_resolution","u_textureSize","kernel0","kernel1","kernel2","kernel3","kernel4","kernelMat","inputStack0","inputStack1","inputStack2","inputStack3","inputStack4","inputStack5","inputStack6","inputStack7","inputStack8","inputStack9","inputStack10","inputStack11","inputStack12","inputStack13","inputStack14","u_bias","kernel_offset","u_flipY"]}formatWeights(e){const t=e.weights,n=this.params.kernelSize*this.params.kernelSize,o=this.params.inChannels,r=Math.round(this.params.inChannels/4+this.params.inChannels%4)%4,i=[],a=[];for(let e=0;e<this.params.kernelSize;e++)for(let t=0;t<this.params.kernelSize;t++)a.push(e%this.params.kernelSize),i.push(t);const u=[];t.slice(this.params.outChannels[0],this.params.outChannels[1]).forEach((function(e,t){const s=[],l=e;for(let e=0;e<n;e++){const t=i[e],n=a[e];for(let e=0;e<o;e++)s.push(l[e][n][t]);for(let e=0;e<r;e++)s.push(0)}u.push(s)}));const s=[];for(let e=0;e<u[0].length/4;e++)for(let t=0;t<4;t++)for(let n=0;n<4;n++)s.push(u[t][4*e+n]);return{weights:{original:u,mat4:s},biases:e.biases.slice(this.params.outChannels[0],this.params.outChannels[1])}}setOutput(e){e.setBuffer("Conv2-1");const t=this.gl;t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1])}setInput(e){const t=this.gl,n=[e.getTexture("Conv1-1"),e.getTexture("Conv1-2")].flat();for(let e=0;e<n.length;e++)t.activeTexture(t.TEXTURE0+e),t.uniform1i(this.locations[`inputStack${e}`],e),t.bindTexture(t.TEXTURE_2D,n[e])}setTextureBufferForLayer(e){const t=this.params.outChannels[1]-this.params.outChannels[0],n=Math.round((t+t%4)/4);e.createBufferWithTextures("Conv2-1",n)}setFragmentPointers(){const e=this.gl,t=this.locations,n=new Float32Array(this.weights.biases);let o=[],r=Math.floor(this.params.kernelSize/2);for(let e=0;e<this.params.kernelSize*this.params.kernelSize;e++){let t=e%this.params.kernelSize-r,n=Math.floor(e/this.params.kernelSize)-r;o.push(t),o.push(n)}e.uniform2f(t.u_textureSize,e.input.w,e.input.h),e.uniformMatrix4fv(t.kernelMat,!1,new Float32Array(this.weights.weights.mat4)),e.uniform4fv(t.kernel4,new Float32Array(this.weights.weights.original[4])),e.uniform1f(t.u_flipY,1),e.uniform1fv(t.u_bias,n),e.uniform2fv(t.kernel_offset,o)}}const f=c;class S extends a.Z{constructor(e,t,n){super(e,t,n)}fragmentShader(){const e=this.gl,t=this.params.outChannels[1]-this.params.outChannels[0],n=this.params.kernelSize*this.params.kernelSize,o=Math.round(this.params.inChannels/4+this.params.inChannels%4)*n;return e.createAndCompileShader(e.FRAGMENT_SHADER,`#version 300 es\n            \n              \n              precision mediump float;\n              \n              /**\n               * Dividing the layer 2 in two parts\n               * part 1 convolves first 32 features from layer 1\n               * part 2 convolves rest 57 - 32 -> 25 features\n               * */\n\n              uniform sampler2D inputStack0 ;\n              uniform sampler2D inputStack1 ;\n              uniform sampler2D inputStack2 ;\n              uniform sampler2D inputStack3 ;\n              uniform sampler2D inputStack4 ;\n              uniform sampler2D inputStack5 ;\n              uniform sampler2D inputStack6 ;\n              uniform sampler2D inputStack7 ;\n              uniform sampler2D inputStack8 ;\n              uniform sampler2D inputStack9 ;\n              uniform sampler2D inputStack10;\n              uniform sampler2D inputStack11;\n              uniform sampler2D inputStack12;\n              uniform sampler2D inputStack13;\n              uniform sampler2D inputStack14;\n              \n              \n              //Use 5 out of 8 total texture channels for the output\n              layout(location = 0) out vec4 outStack0;\n              layout(location = 1) out vec4 outStack1;\n\n              /**\n               * For layer2 part 1\n               * per kernel size -> 0 to 9\n               * number of input textures -> 57\n               * Required array size -> 60*9 -> 540\n               * vec4 kernelN of size 135 provides -> 4*135 -> 540 positions\n               * Also we have 5 output features so we need 5 kernelNs\n               * */\n\n\n              uniform mat4 kernelMat[${o}];\n              uniform vec4 kernel4[${o}];\n              \n              \n              \n              // 5 biases for 5 outputs\n              uniform float u_bias[${t}];\n              \n              in vec2 v_texCoord;\n              \n              //kernel_offset size 9 due to 3x3 kernels\n              uniform vec2 kernel_offset[${n}];\n              uniform vec2 u_textureSize;\n              \n             \n            \n              void main() {\n           \n                    vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n                    \n                    for (int i =0; i < kernel_offset.length(); i++){\n                    \n                    \n                        outStack0 += texture(inputStack0, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 0];\n                        outStack0 += texture(inputStack1, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 1];\n                        outStack0 += texture(inputStack2, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 2];\n                        outStack0 += texture(inputStack3, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 3];\n                        outStack0 += texture(inputStack4, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 4];\n                        outStack0 += texture(inputStack5, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 5];\n                        outStack0 += texture(inputStack6, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 6];\n                        outStack0 += texture(inputStack7, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 7];\n                        outStack0 += texture(inputStack8, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 8];\n                        outStack0 += texture(inputStack9, v_texCoord + onePixel *kernel_offset[i])* kernelMat[i*15 + 9];\n                        outStack0 += texture(inputStack10, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 10];\n                        outStack0 += texture(inputStack11, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 11];\n                        outStack0 += texture(inputStack12, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 12];\n                        outStack0 += texture(inputStack13, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 13];\n                        outStack0 += texture(inputStack14, v_texCoord + onePixel *kernel_offset[i])*kernelMat[i*15 + 14];\n                        \n                        \n                        \n                        outStack1[0] += dot(texture(inputStack0, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 0]);\n                        outStack1[0] += dot(texture(inputStack1, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 1]);\n                        outStack1[0] += dot(texture(inputStack2, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 2]);\n                        outStack1[0] += dot(texture(inputStack3, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 3]);\n                        outStack1[0] += dot(texture(inputStack4, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 4]);\n                        outStack1[0] += dot(texture(inputStack5, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 5]);\n                        outStack1[0] += dot(texture(inputStack6, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 6]);\n                        outStack1[0] += dot(texture(inputStack7, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 7]);\n                        outStack1[0] += dot(texture(inputStack8, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 8]);\n                        outStack1[0] += dot(texture(inputStack9, v_texCoord + onePixel *kernel_offset[i]), kernel4[i*15 + 9]);\n                        outStack1[0] += dot(texture(inputStack10, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 10]);\n                        outStack1[0] += dot(texture(inputStack11, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 11]);\n                        outStack1[0] += dot(texture(inputStack12, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 12]);\n                        outStack1[0] += dot(texture(inputStack13, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 13]);\n                        outStack1[0] += dot(texture(inputStack14, v_texCoord + onePixel *kernel_offset[i]),kernel4[i*15 + 14]);\n                             \n                    }\n              \n                              \n                    outStack0[0] += u_bias[0];\n                    outStack0[0] = max(0.0, outStack0[0]);\n\n                    outStack0[1] += u_bias[1];\n                    outStack0[1] = max(0.0, outStack0[1]);\n\n                    outStack0[2] += u_bias[2];\n                    outStack0[2] = max(0.0, outStack0[2]);\n\n                    outStack0[3] += u_bias[3];\n                    outStack0[3] = max(0.0, outStack0[3]);\n                    \n                    outStack1[0] += u_bias[4];\n                    outStack1[0] = max(0.0, outStack1[0]);\n                                               \n              }\n        `)}attributes(){return["a_position","a_texCoord"]}uniforms(){return["u_resolution","u_textureSize","kernel0","kernel1","kernel2","kernel3","kernel4","kernelMat","inputStack0","inputStack1","inputStack2","inputStack3","inputStack4","inputStack5","inputStack6","inputStack7","inputStack8","inputStack9","inputStack10","inputStack11","inputStack12","inputStack13","inputStack14","u_bias","kernel_offset","u_flipY"]}formatWeights(e){const t=e.weights,n=this.params.kernelSize*this.params.kernelSize,o=this.params.inChannels,r=Math.round(this.params.inChannels/4+this.params.inChannels%4)%4,i=[],a=[];for(let e=0;e<this.params.kernelSize;e++)for(let t=0;t<this.params.kernelSize;t++)a.push(e%this.params.kernelSize),i.push(t);const u=[];t.slice(this.params.outChannels[0],this.params.outChannels[1]).forEach((function(e){const t=[],s=e;for(let e=0;e<n;e++){const n=i[e],u=a[e];for(let e=0;e<o;e++)t.push(s[e][u][n]);for(let e=0;e<r;e++)t.push(0)}u.push(t)}));const s=[];for(let e=0;e<u[0].length/4;e++)for(let t=0;t<4;t++)for(let n=0;n<4;n++)s.push(u[t][4*e+n]);return{weights:{original:u,mat4:s},biases:e.biases.slice(this.params.outChannels[0],this.params.outChannels[1])}}setOutput(e){e.setBuffer("Conv2-2");const t=this.gl;t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1])}setInput(e){const t=this.gl,n=[e.getTexture("Conv1-1"),e.getTexture("Conv1-2")].flat();for(let e=0;e<n.length;e++)t.activeTexture(t.TEXTURE0+e),t.uniform1i(this.locations[`inputStack${e}`],e),t.bindTexture(t.TEXTURE_2D,n[e])}setTextureBufferForLayer(e){const t=this.params.outChannels[1]-this.params.outChannels[0],n=Math.round((t+t%4)/4);e.createBufferWithTextures("Conv2-2",n)}setFragmentPointers(){const e=this.gl,t=this.locations,n=new Float32Array(this.weights.biases);let o=[],r=Math.floor(this.params.kernelSize/2);for(let e=0;e<this.params.kernelSize*this.params.kernelSize;e++){let t=e%this.params.kernelSize-r,n=Math.floor(e/this.params.kernelSize)-r;o.push(t),o.push(n)}e.uniform2f(t.u_textureSize,e.input.w,e.input.h),e.uniformMatrix4fv(t.kernelMat,!1,new Float32Array(this.weights.weights.mat4)),e.uniform4fv(t.kernel4,new Float32Array(this.weights.weights.original[4])),e.uniform1f(t.u_flipY,1),e.uniform1fv(t.u_bias,n),e.uniform2fv(t.kernel_offset,o)}}const x=S;class _ extends a.Z{constructor(e,t,n){super(e,t,n)}fragmentShader(){const e=this.params.outChannels[1]-this.params.outChannels[0],t=this.params.kernelSize*this.params.kernelSize,n=Math.round(this.params.inChannels/4+this.params.inChannels%4)*t,o=this.gl;return o.createAndCompileShader(o.FRAGMENT_SHADER,`#version 300 es\n            \n              \n              precision mediump float;\n\n              uniform sampler2D inputStack0 ;\n              uniform sampler2D inputStack1 ;\n              uniform sampler2D inputStack2 ;\n              uniform sampler2D inputStack3 ;\n              \n              \n              //Use 5 out of 8 total texture channels for the output\n              layout(location = 0) out vec4 outStack0;\n              layout(location = 1) out vec4 outStack1;\n\n\n              uniform vec4 kernel0[${n}];\n              uniform vec4 kernel1[${n}];\n              uniform vec4 kernel2[${n}];\n              uniform vec4 kernel3[${n}];\n              uniform vec4 kernel4[${n}];\n              uniform vec4 kernel5[${n}];\n              \n              \n              \n              // 6 biases for 6 outputs\n              uniform float u_bias[${e}];\n              \n              in vec2 v_texCoord;\n              \n              //kernel_offset size 9 due to 3x3 kernels\n              uniform vec2 kernel_offset[${t}];\n              uniform vec2 u_textureSize;\n              \n             \n            \n              void main() {\n           \n                    vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n                    \n                    for (int i =0; i < kernel_offset.length(); i++){\n                    \n                        outStack0[0] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel0[i*4 + 0]);\n                        outStack0[0] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel0[i*4 + 1]);\n                        outStack0[0] += dot(texture(inputStack2, v_texCoord + onePixel * kernel_offset[i]), kernel0[i*4 + 2]);\n                        outStack0[0] += dot(texture(inputStack3, v_texCoord + onePixel * kernel_offset[i]), kernel0[i*4 + 3]);\n \n                        outStack0[1] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel1[i*4 + 0]);\n                        outStack0[1] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel1[i*4 + 1]);\n                        outStack0[1] += dot(texture(inputStack2, v_texCoord + onePixel * kernel_offset[i]), kernel1[i*4 + 2]);\n                        outStack0[1] += dot(texture(inputStack3, v_texCoord + onePixel * kernel_offset[i]), kernel1[i*4 + 3]);\n \n                        outStack0[2] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel2[i*4 + 0]);\n                        outStack0[2] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel2[i*4 + 1]);\n                        outStack0[2] += dot(texture(inputStack2, v_texCoord + onePixel * kernel_offset[i]), kernel2[i*4 + 2]);\n                        outStack0[2] += dot(texture(inputStack3, v_texCoord + onePixel * kernel_offset[i]), kernel2[i*4 + 3]);\n                         \n                        outStack0[3] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel3[i*4 + 0]);\n                        outStack0[3] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel3[i*4 + 1]);\n                        outStack0[3] += dot(texture(inputStack2, v_texCoord + onePixel * kernel_offset[i]), kernel3[i*4 + 2]);\n                        outStack0[3] += dot(texture(inputStack3, v_texCoord + onePixel * kernel_offset[i]), kernel3[i*4 + 3]);\n \n                        outStack1[0] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel4[i*4 + 0]);\n                        outStack1[0] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel4[i*4 + 1]);\n                        outStack1[0] += dot(texture(inputStack2, v_texCoord + onePixel * kernel_offset[i]), kernel4[i*4 + 2]);\n                        outStack1[0] += dot(texture(inputStack3, v_texCoord + onePixel * kernel_offset[i]), kernel4[i*4 + 3]);\n \n                        outStack1[1] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel5[i*4 + 0]);\n                        outStack1[1] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel5[i*4 + 1]);\n                        outStack1[1] += dot(texture(inputStack2, v_texCoord + onePixel * kernel_offset[i]), kernel5[i*4 + 2]);\n                        outStack1[1] += dot(texture(inputStack3, v_texCoord + onePixel * kernel_offset[i]), kernel5[i*4 + 3]);\n                             \n                    }\n                    \n              \n                              \n                    outStack0[0] += u_bias[0];\n                    outStack0[0] = max(0.0, outStack0[0]);\n\n                    outStack0[1] += u_bias[1];\n                    outStack0[1] = max(0.0, outStack0[1]);\n\n                    outStack0[2] += u_bias[2];\n                    outStack0[2] = max(0.0, outStack0[2]);\n\n                    outStack0[3] += u_bias[3];\n                    outStack0[3] = max(0.0, outStack0[3]);\n                    \n                    outStack1[0] += u_bias[4];\n                    outStack1[0] = max(0.0, outStack1[0]);\n\n                    outStack1[1] += u_bias[5];\n                    outStack1[1] = max(0.0, outStack1[1]);\n                    \n                             \n              }\n        `)}attributes(){return["a_position","a_texCoord"]}uniforms(){return["u_resolution","u_textureSize","kernel0","kernel1","kernel2","kernel3","kernel4","kernel5","inputStack0","inputStack1","inputStack2","inputStack3","u_bias","kernel_offset","u_flipY"]}formatWeights(e){const t=e.weights,n=[];return t.slice(this.params.outChannels[0],this.params.outChannels[1]).forEach((function(e){const t=[],o=[0,1,2,0,1,2,0,1,2],r=[0,0,0,1,1,1,2,2,2],i=e;for(let e=0;e<9;e++){const n=o[e],a=r[e];for(let e=0;e<2;e++){for(let o=5*e;o<5*(e+1);o++)t.push(i[o][a][n]);for(let e=0;e<3;e++)t.push(0)}}n.push(t)})),{weights:n,biases:e.biases.slice(0,6)}}setOutput(e){e.setBuffer("Conv3");const t=this.gl;t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1])}setInput(e){const t=this.gl,n=[e.getTexture("Conv2-1"),e.getTexture("Conv2-2")].flat();for(let e=0;e<n.length;e++)t.activeTexture(t.TEXTURE0+e),t.uniform1i(this.locations[`inputStack${e}`],e),t.bindTexture(t.TEXTURE_2D,n[e])}setTextureBufferForLayer(e){e.createBufferWithTextures("Conv3",2)}setFragmentPointers(){const e=this.gl,t=this.locations,n=new Float32Array(this.weights.biases),o=new Float32Array([-1,-1,0,-1,1,-1,-1,0,0,0,1,0,-1,1,0,1,1,1]);e.uniform2f(t.u_textureSize,e.input.w,e.input.h);for(let n=0;n<6;n++)e.uniform4fv(t[`kernel${n}`],new Float32Array(this.weights.weights[n]));e.uniform1f(t.u_flipY,1),e.uniform1fv(t.u_bias,n),e.uniform2fv(t.kernel_offset,o)}}const p=_;class h extends a.Z{constructor(e,t,n){super(e,t,n)}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n            \n              \n              precision mediump float;\n\n              uniform sampler2D inputStack0 ;\n              uniform sampler2D inputStack1 ;\n              \n              \n              //Use 9 out of 12 total texture channels for the output\n              layout(location = 0) out vec4 outStack0;\n              layout(location = 1) out vec4 outStack1;\n              layout(location = 2) out vec4 outStack2;\n\n\n              uniform vec4 kernel0[18];\n              uniform vec4 kernel1[18];\n              uniform vec4 kernel2[18];\n              uniform vec4 kernel3[18];\n              uniform vec4 kernel4[18];\n              uniform vec4 kernel5[18];\n              uniform vec4 kernel6[18];\n              uniform vec4 kernel7[18];\n              uniform vec4 kernel8[18];\n              \n              \n              \n              // 9 biases for 9 outputs\n              uniform float u_bias[9];\n              \n              in vec2 v_texCoord;\n              \n              //kernel_offset size 9 due to 3x3 kernels\n              uniform vec2 kernel_offset[9];\n              uniform vec2 u_textureSize;\n              \n             \n            \n              void main() {\n           \n                    vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n                    \n                    for (int i =0; i < 9; i++){\n                    \n                        outStack0[0] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel0[i*2 + 0]);\n                        outStack0[0] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel0[i*2 + 1]);\n \n                        outStack0[1] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel1[i*2 + 0]);\n                        outStack0[1] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel1[i*2 + 1]);\n \n                        outStack0[2] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel2[i*2 + 0]);\n                        outStack0[2] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel2[i*2 + 1]);\n                         \n                        outStack0[3] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel3[i*2 + 0]);\n                        outStack0[3] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel3[i*2 + 1]);\n \n                        outStack1[0] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel4[i*2 + 0]);\n                        outStack1[0] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel4[i*2 + 1]);\n \n                        outStack1[1] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel5[i*2 + 0]);\n                        outStack1[1] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel5[i*2 + 1]);\n\n                        outStack1[2] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel6[i*2 + 0]);\n                        outStack1[2] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel6[i*2 + 1]);\n\n                        outStack1[3] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel7[i*2 + 0]);\n                        outStack1[3] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel7[i*2 + 1]);\n\n                        outStack2[0] += dot(texture(inputStack0, v_texCoord + onePixel * kernel_offset[i]), kernel8[i*2 + 0]);\n                        outStack2[0] += dot(texture(inputStack1, v_texCoord + onePixel * kernel_offset[i]), kernel8[i*2 + 1]);\n\n                             \n                    }\n                                               \n                    outStack0[0] += u_bias[0];\n                    outStack0[0] = max(0.0, outStack0[0]);\n\n                    outStack0[1] += u_bias[1];\n                    outStack0[1] = max(0.0, outStack0[1]);\n\n                    outStack0[2] += u_bias[2];\n                    outStack0[2] = max(0.0, outStack0[2]);\n\n                    outStack0[3] += u_bias[3];\n                    outStack0[3] = max(0.0, outStack0[3]);\n                    \n                    outStack1[0] += u_bias[4];\n                    outStack1[0] = max(0.0, outStack1[0]);\n\n                    outStack1[1] += u_bias[5];\n                    outStack1[1] = max(0.0, outStack1[1]);\n\n                    outStack1[2] += u_bias[6];\n                    outStack1[2] = max(0.0, outStack1[2]);\n\n                    outStack1[3] += u_bias[7];\n                    outStack1[3] = max(0.0, outStack1[3]);\n\n                    outStack2[0] += u_bias[8];\n                    outStack2[0] = max(0.0, outStack2[0]);\n                             \n              }\n        ")}attributes(){return["a_position","a_texCoord"]}uniforms(){return["u_resolution","u_textureSize","kernel0","kernel1","kernel2","kernel3","kernel4","kernel5","kernel6","kernel7","kernel8","inputStack0","inputStack1","u_bias","kernel_offset","u_flipY"]}formatWeights(e){const t=e.weights,n=[];return t.slice(0,9).forEach((function(e,t){const o=[],r=[0,1,2,0,1,2,0,1,2],i=[0,0,0,1,1,1,2,2,2],a=e;for(let e=0;e<9;e++){const t=r[e],n=i[e];for(let e=0;e<6;e++)o.push(a[e][n][t]);for(let e=0;e<2;e++)o.push(0)}n.push(o)})),{weights:n,biases:e.biases.slice(0,9)}}setOutput(e){e.setBuffer("Conv4");const t=this.gl;t.drawBuffers([t.COLOR_ATTACHMENT0,t.COLOR_ATTACHMENT1,t.COLOR_ATTACHMENT2])}setInput(e){const t=this.gl,n=e.getTexture("Conv3");for(let e=0;e<n.length;e++)t.activeTexture(t.TEXTURE0+e),t.uniform1i(this.locations[`inputStack${e}`],e),t.bindTexture(t.TEXTURE_2D,n[e])}setTextureBufferForLayer(e){e.createBufferWithTextures("Conv4",3)}setFragmentPointers(){const e=this.gl,t=this.locations,n=new Float32Array(this.weights.biases),o=new Float32Array([-1,-1,0,-1,1,-1,-1,0,0,0,1,0,-1,1,0,1,1,1]);e.uniform2f(t.u_textureSize,e.input.w,e.input.h);for(let n=0;n<9;n++)e.uniform4fv(t[`kernel${n}`],new Float32Array(this.weights.weights[n]));e.uniform1f(t.u_flipY,1),e.uniform1fv(t.u_bias,n),e.uniform2fv(t.kernel_offset,o)}}const m=h;var v=n(67);class d extends v.Z{constructor(e,t){super(e),this.layer_name=t}fragmentShader(){const e=this.gl;return e.createAndCompileShader(e.FRAGMENT_SHADER,"#version 300 es\n            precision mediump float;\n            \n            uniform sampler2D inputStack0;\n            uniform sampler2D inputStack1;\n            uniform sampler2D inputStack2;\n\n            uniform sampler2D YUV;\n            \n            uniform vec2 u_textureSize;\n            \n            in vec2 v_texCoord;\n            out vec4 outColor;\n            \n            void main() {\n            \n            \n                    vec2 canvasCoords = v_texCoord*u_textureSize;\n\n                    int i = int(canvasCoords[0]);\n                    int j  = int(canvasCoords[1]);\n                    \n\n                    if(i % 3 == 0 && j % 3 ==0){\n                        outColor[0] = texture(inputStack0, v_texCoord)[0];\n                    }\n                    \n                    else if(i % 3 == 1 && j % 3 ==0){\n                        outColor[0] = texture(inputStack0, v_texCoord)[1];\n                    }\n                                        \n                    else if(i % 3 == 2 && j % 3 == 0){\n                        outColor[0] = texture(inputStack0, v_texCoord)[2];\n                    }\n                    \n                    else if(i % 3 == 0 && j % 3 ==1){\n                        outColor[0] = texture(inputStack0, v_texCoord)[3];\n                    }\n                    else if(i % 3 == 1 && j % 3 ==1){\n                        outColor[0] = texture(inputStack1, v_texCoord)[0];\n                    }\n                    \n                    else if(i % 3 == 2 && j % 3 ==1){\n                        outColor[0] = texture(inputStack1, v_texCoord)[1];\n                    }\n\n                    else if(i % 3 == 0 && j % 3 ==2){\n                        outColor[0] = texture(inputStack1, v_texCoord)[2];\n                    }\n                    else if(i % 3 == 1 && j % 3 ==2){\n                        outColor[0] = texture(inputStack1, v_texCoord)[3];\n                    }\n                    else if(i % 3 == 2 && j % 3 ==2){\n                        outColor[0] = texture(inputStack2, v_texCoord)[0];\n                    }\n                    \n                    outColor[1] =  texture(YUV, v_texCoord)[1];\n                    outColor[2] =  texture(YUV, v_texCoord)[2];\n                    outColor[3] = 1.0;\n                    \n            }\n        ")}setOutput(e){e.setBuffer("PixelShuffle")}setTextureBufferForLayer(e){e.createBufferWithTextures("PixelShuffle",1,3)}setInput(e){const t=this.gl;t.uniform1i(this.locations.inputStack0,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e.getTexture(this.layer_name)[0]),t.uniform1i(this.locations.inputStack1,1),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,e.getTexture(this.layer_name)[1]),t.uniform1i(this.locations.inputStack2,2),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,e.getTexture(this.layer_name)[2]),t.uniform1i(this.locations.YUV,3),t.activeTexture(t.TEXTURE3),t.bindTexture(t.TEXTURE_2D,e.getTexture("YUV")[0])}uniforms(){return["u_resolution","u_textureSize","YUV","inputStack0","inputStack1","inputStack2","bias","kernel_offset","u_flipY"]}setFragmentPointers(){const e=this.gl,t=this.locations;e.drawBuffers([e.COLOR_ATTACHMENT0]),e.uniform2f(t.u_textureSize,3*e.input.w,3*e.input.h),e.uniform1f(t.u_flipY,1)}}const C=d;class T extends o.Z{constructor(e,t,n){super(e,t,n)}async getImageBytes(){}model(){const e=this.gl;return e.resizeCanvasToDisplaySize(3),[new r.Z(e,{scale:3}),new s(e,this.Parameters.conv1,{scale:3,kernelSize:5,inChannels:1,outChannels:[0,32]}),new k(e,this.Parameters.conv1,{scale:3,kernelSize:5,inChannels:1,outChannels:[32,57]}),new f(e,this.Parameters.conv2,{scale:3,kernelSize:3,inChannels:57,outChannels:[0,5]}),new x(e,this.Parameters.conv2,{scale:3,kernelSize:3,inChannels:57,outChannels:[5,10]}),new p(e,this.Parameters.conv3,{scale:3,kernelSize:3,inChannels:18,outChannels:[0,6]}),new m(e,this.Parameters.conv4,{scale:3,kernelSize:3,inChannels:6,outChannels:[0,9]}),new C(e,"Conv4"),new i.Z(e)]}}const g=T}}]);